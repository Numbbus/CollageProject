from PIL import Image
import ast
import numpy as np
from datetime import datetime

startDate = datetime.now()

# Define parameters for the collage 

# The bigger the resolution the larger each image in the collage will be
resolution = 10

# Path to input image
inputImage = "helldiver2.png"

#Path to input images
inputImagesPath = "images"

completedNum = 0
tolerance = 10

# Reading in the txt file generated by the picsum_downloader.py
# Since it is a string we are using a literal evalutaion to get an array of tuples
# The index of a tupel corrisponds to the image with the same number at the end of its file name
with open(f"{inputImagesPath}/avg_rgb_values.txt", "r") as file:
    allRgbVals = ast.literal_eval(file.readline())

img = Image.open(inputImage)
#img.show()

output_img = Image.new('RGB', (int(img.width/resolution) * resolution, int(img.height/resolution) * resolution))

total = int(img.height/resolution) * int(img.width/resolution)

for y in range(int(img.height/resolution)):
    for x in range(int(img.width/resolution)):
        crop_dimensions = (x*resolution, y*resolution, x*resolution+resolution, y*resolution+resolution)

        cropped_image = img.crop(crop_dimensions)

        # Find best matching image to replace it
        foundImage = False
        currentRGBindex = 0
        imagesIndex = 0

        while(not(foundImage)):
            currentRGBVals = allRgbVals[currentRGBindex]

            currentRGBindex+=1

            if(currentRGBindex >= len(allRgbVals)):
                #print("Error")
                currentRGBindex=0
                tolerance+=5
            
                

            cropped_image = cropped_image.convert('RGB')

            # Retrieve the width and height of the image.
            width, height = cropped_image.size

            # Initialize a list to store RGB values.
            rgb_values = []

            # Use a list comprehension to populate the list with RGB values of each pixel.
            rgb_values = [cropped_image.getpixel((x, y)) for y in range(height) for x in range(width)]

            averageRgbValues = (0, 0, 0)
            totalRgbValues = (0, 0, 0)

            counter = 0

            for val in rgb_values:
                totalRgbValues = (totalRgbValues[0] + val[0], totalRgbValues[1] + val[1], totalRgbValues[2] + val[2])

                counter+=1

            croppedImageAverageRgbValues = (int(totalRgbValues[0] / counter), int(totalRgbValues[1] / counter), int(totalRgbValues[2] / counter))

            #print((currentRGBVals[1] - croppedImageAverageRgbValues[1] <= tolerance))
            #print((currentRGBVals[2] - croppedImageAverageRgbValues[2] <= tolerance))

            if((abs(currentRGBVals[0] - croppedImageAverageRgbValues[0]) <= tolerance) and (abs(currentRGBVals[1] - croppedImageAverageRgbValues[1]) <= tolerance) and (abs(currentRGBVals[2] - croppedImageAverageRgbValues[2]) <= tolerance)):
                
                selectedImg = Image.open(f"{inputImagesPath}/picsumImg{currentRGBindex}.png")

                selectedImg = selectedImg.resize( (resolution, resolution) )

                #print(f"Cropped RGB: {croppedImageAverageRgbValues}\nSelected Image RGB: {currentRGBVals}\n")

                output_img.paste(selectedImg, (x*resolution, y*resolution))
                output_img.save("output.png")
                foundImage = True
                tolerance=10
                completedNum+=1
                print(f"Completed {completedNum}/{total}")
            
            

        
        #print(crop_dimensions)
        
        
        #cropped_image.show()

output_img.show()
print(f"Elapsed Time: {int((datetime.now().timestamp() - startDate.timestamp()))/60}m")
